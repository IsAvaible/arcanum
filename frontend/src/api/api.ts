/* tslint:disable */
/* eslint-disable */
/**
 * Oculavis Arcanum API
 * The Oculavis Arcanum API allows you to manage cases by creating, retrieving, updating, and deleting them. It also supports file attachments associated with cases. The API also includes endpoints for managing chat functionality, including creating, retrieving, updating, and exporting chat sessions and messages. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * ID of the attachment.
     * @type {number}
     * @memberof Attachment
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'filename': string;
    /**
     * Path to the attachment file.
     * @type {string}
     * @memberof Attachment
     */
    'filepath': string;
    /**
     * Hash of the attachment file.
     * @type {string}
     * @memberof Attachment
     */
    'filehash': string;
    /**
     * MIME type of the attachment file.
     * @type {string}
     * @memberof Attachment
     */
    'mimetype': string;
    /**
     * Size of the attachment file in bytes.
     * @type {number}
     * @memberof Attachment
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Case
 */
export interface Case {
    /**
     * Title of the case.
     * @type {string}
     * @memberof Case
     */
    'title': string;
    /**
     * Description of the case.
     * @type {string}
     * @memberof Case
     */
    'description': string;
    /**
     * Solution for the case.
     * @type {string}
     * @memberof Case
     */
    'solution'?: string;
    /**
     * Person responsible for the case.
     * @type {Array<string>}
     * @memberof Case
     */
    'assignees': Array<string>;
    /**
     * Status of the case.
     * @type {string}
     * @memberof Case
     */
    'status'?: CaseStatusEnum;
    /**
     * Type of the case.
     * @type {string}
     * @memberof Case
     */
    'case_type'?: CaseCaseTypeEnum;
    /**
     * Priority level of the case.
     * @type {string}
     * @memberof Case
     */
    'priority'?: CasePriorityEnum;
    /**
     * ID of the case.
     * @type {number}
     * @memberof Case
     */
    'id': number;
    /**
     * Indicates whether the case is a draft.
     * @type {boolean}
     * @memberof Case
     */
    'draft': boolean;
    /**
     * Date and time the case was created.
     * @type {string}
     * @memberof Case
     */
    'createdAt': string;
    /**
     * Date and time the case was last updated.
     * @type {string}
     * @memberof Case
     */
    'updatedAt': string;
    /**
     * List of attachments attached to the case.
     * @type {Array<Attachment>}
     * @memberof Case
     */
    'attachments': Array<Attachment>;
    /**
     * List of changes made to the case.
     * @type {Array<CaseChangeHistoryEntry>}
     * @memberof Case
     */
    'changeHistory': Array<CaseChangeHistoryEntry>;
}

export const CaseStatusEnum = {
    Open: 'Open',
    InProgress: 'In Progress',
    Solved: 'Solved',
    Closed: 'Closed'
} as const;

export type CaseStatusEnum = typeof CaseStatusEnum[keyof typeof CaseStatusEnum];
export const CaseCaseTypeEnum = {
    Problem: 'Problem',
    Incident: 'Incident',
    Change: 'Change',
    Faq: 'FAQ'
} as const;

export type CaseCaseTypeEnum = typeof CaseCaseTypeEnum[keyof typeof CaseCaseTypeEnum];
export const CasePriorityEnum = {
    Low: 'Low',
    Medium: 'Medium',
    High: 'High'
} as const;

export type CasePriorityEnum = typeof CasePriorityEnum[keyof typeof CasePriorityEnum];

/**
 * 
 * @export
 * @interface CaseBase
 */
export interface CaseBase {
    /**
     * Title of the case.
     * @type {string}
     * @memberof CaseBase
     */
    'title': string;
    /**
     * Description of the case.
     * @type {string}
     * @memberof CaseBase
     */
    'description': string;
    /**
     * Solution for the case.
     * @type {string}
     * @memberof CaseBase
     */
    'solution'?: string;
    /**
     * Person responsible for the case.
     * @type {Array<string>}
     * @memberof CaseBase
     */
    'assignees': Array<string>;
    /**
     * Status of the case.
     * @type {string}
     * @memberof CaseBase
     */
    'status'?: CaseBaseStatusEnum;
    /**
     * Type of the case.
     * @type {string}
     * @memberof CaseBase
     */
    'case_type'?: CaseBaseCaseTypeEnum;
    /**
     * Priority level of the case.
     * @type {string}
     * @memberof CaseBase
     */
    'priority'?: CaseBasePriorityEnum;
}

export const CaseBaseStatusEnum = {
    Open: 'Open',
    InProgress: 'In Progress',
    Solved: 'Solved',
    Closed: 'Closed'
} as const;

export type CaseBaseStatusEnum = typeof CaseBaseStatusEnum[keyof typeof CaseBaseStatusEnum];
export const CaseBaseCaseTypeEnum = {
    Problem: 'Problem',
    Incident: 'Incident',
    Change: 'Change',
    Faq: 'FAQ'
} as const;

export type CaseBaseCaseTypeEnum = typeof CaseBaseCaseTypeEnum[keyof typeof CaseBaseCaseTypeEnum];
export const CaseBasePriorityEnum = {
    Low: 'Low',
    Medium: 'Medium',
    High: 'High'
} as const;

export type CaseBasePriorityEnum = typeof CaseBasePriorityEnum[keyof typeof CaseBasePriorityEnum];

/**
 * 
 * @export
 * @interface CaseChangeHistoryEntry
 */
export interface CaseChangeHistoryEntry {
    /**
     * ID of the change history entry.
     * @type {number}
     * @memberof CaseChangeHistoryEntry
     */
    'id': number;
    /**
     * ID of the case the change was made to.
     * @type {number}
     * @memberof CaseChangeHistoryEntry
     */
    'caseId': number;
    /**
     * Timestamp the change was made at.
     * @type {string}
     * @memberof CaseChangeHistoryEntry
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     * Chat ID.
     * @type {number}
     * @memberof Chat
     */
    'id': number;
    /**
     * Title of the chat.
     * @type {string}
     * @memberof Chat
     */
    'title'?: string;
    /**
     * Date the chat was created.
     * @type {string}
     * @memberof Chat
     */
    'createdAt'?: string;
    /**
     * Date the chat was last updated.
     * @type {string}
     * @memberof Chat
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ChatWithMessages
 */
export interface ChatWithMessages {
    /**
     * Chat ID.
     * @type {number}
     * @memberof ChatWithMessages
     */
    'id': number;
    /**
     * Title of the chat.
     * @type {string}
     * @memberof ChatWithMessages
     */
    'title'?: string;
    /**
     * Date the chat was created.
     * @type {string}
     * @memberof ChatWithMessages
     */
    'createdAt'?: string;
    /**
     * Date the chat was last updated.
     * @type {string}
     * @memberof ChatWithMessages
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof ChatWithMessages
     */
    'messages': Array<Message>;
}
/**
 * 
 * @export
 * @interface ChatsIdMessagesPost200Response
 */
export interface ChatsIdMessagesPost200Response {
    /**
     * 
     * @type {Message}
     * @memberof ChatsIdMessagesPost200Response
     */
    'userMessage': Message;
    /**
     * 
     * @type {Message}
     * @memberof ChatsIdMessagesPost200Response
     */
    'assistantMessage': Message;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * Message ID.
     * @type {number}
     * @memberof Message
     */
    'id': number;
    /**
     * ID of the chat the message belongs to.
     * @type {number}
     * @memberof Message
     */
    'chatId': number;
    /**
     * Role of the message sender.
     * @type {string}
     * @memberof Message
     */
    'role': MessageRoleEnum;
    /**
     * Content of the message.
     * @type {string}
     * @memberof Message
     */
    'content': string;
    /**
     * Time the message was sent.
     * @type {string}
     * @memberof Message
     */
    'timestamp': string;
}

export const MessageRoleEnum = {
    User: 'user',
    Assistant: 'assistant'
} as const;

export type MessageRoleEnum = typeof MessageRoleEnum[keyof typeof MessageRoleEnum];

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error message.
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
    /**
     * HTTP status code for the error.
     * @type {number}
     * @memberof ModelError
     */
    'code'?: number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download an attachment by its ID.
         * @summary Download an attachment
         * @param {number} attachmentId ID of the attachment to download.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesAttachmentsAttachmentIdDownloadGet: async (attachmentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('casesAttachmentsAttachmentIdDownloadGet', 'attachmentId', attachmentId)
            const localVarPath = `/cases/attachments/{attachmentId}/download`
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an attachment by its ID.
         * @summary Retrieve an attachment
         * @param {number} attachmentId ID of the attachment to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesAttachmentsAttachmentIdGet: async (attachmentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('casesAttachmentsAttachmentIdGet', 'attachmentId', attachmentId)
            const localVarPath = `/cases/attachments/{attachmentId}`
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all cases.
         * @summary Retrieve all cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an attachment associated with a case.
         * @summary Delete an attachment
         * @param {number} id ID of the case.
         * @param {number} attachmentId ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdAttachmentsAttachmentIdDelete: async (id: number, attachmentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('casesIdAttachmentsAttachmentIdDelete', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('casesIdAttachmentsAttachmentIdDelete', 'attachmentId', attachmentId)
            const localVarPath = `/cases/{id}/attachments/{attachmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download an attachment associated with a case.
         * @summary Download an attachment
         * @param {number} id ID of the case.
         * @param {number} attachmentId ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdAttachmentsAttachmentIdDownloadGet: async (id: number, attachmentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('casesIdAttachmentsAttachmentIdDownloadGet', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('casesIdAttachmentsAttachmentIdDownloadGet', 'attachmentId', attachmentId)
            const localVarPath = `/cases/{id}/attachments/{attachmentId}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an attachment associated with a case.
         * @summary Retrieve an attachment
         * @param {number} id ID of the case.
         * @param {number} attachmentId ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdAttachmentsAttachmentIdGet: async (id: number, attachmentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('casesIdAttachmentsAttachmentIdGet', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('casesIdAttachmentsAttachmentIdGet', 'attachmentId', attachmentId)
            const localVarPath = `/cases/{id}/attachments/{attachmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload one or more files as attachments for a specific case.
         * @summary Upload attachments for a case
         * @param {number} id ID of the case to which the files will be attached.
         * @param {Array<File>} [files] Files to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdAttachmentsPost: async (id: number, files?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('casesIdAttachmentsPost', 'id', id)
            const localVarPath = `/cases/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific case by its ID.
         * @summary Delete a case by ID
         * @param {number} id ID of the case to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('casesIdDelete', 'id', id)
            const localVarPath = `/cases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific case by its ID.
         * @summary Retrieve a case by ID
         * @param {number} id ID of the case to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('casesIdGet', 'id', id)
            const localVarPath = `/cases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing case by its ID.
         * @summary Update a case by ID
         * @param {number} id ID of the case to update.
         * @param {string} title Title of the case.
         * @param {string} description Description of the case.
         * @param {Array<string>} assignees Person responsible for the case.
         * @param {string} [solution] Solution for the case.
         * @param {CasesIdPutStatusEnum} [status] Status of the case.
         * @param {CasesIdPutCaseTypeEnum} [caseType] Type of the case.
         * @param {CasesIdPutPriorityEnum} [priority] Priority level of the case.
         * @param {Array<File>} [files] Attached files on upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdPut: async (id: number, title: string, description: string, assignees: Array<string>, solution?: string, status?: CasesIdPutStatusEnum, caseType?: CasesIdPutCaseTypeEnum, priority?: CasesIdPutPriorityEnum, files?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('casesIdPut', 'id', id)
            // verify required parameter 'title' is not null or undefined
            assertParamExists('casesIdPut', 'title', title)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('casesIdPut', 'description', description)
            // verify required parameter 'assignees' is not null or undefined
            assertParamExists('casesIdPut', 'assignees', assignees)
            const localVarPath = `/cases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (solution !== undefined) { 
                localVarFormParams.append('solution', solution as any);
            }
                if (assignees) {
                localVarFormParams.append('assignees', assignees.join(COLLECTION_FORMATS.csv));
            }

    
            if (status !== undefined) { 
                localVarFormParams.append('status', status as any);
            }
    
            if (caseType !== undefined) { 
                localVarFormParams.append('case_type', caseType as any);
            }
    
            if (priority !== undefined) { 
                localVarFormParams.append('priority', priority as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new case.
         * @summary Create a new case
         * @param {string} title Title of the case.
         * @param {string} description Description of the case.
         * @param {Array<string>} assignees Person responsible for the case.
         * @param {string} [solution] Solution for the case.
         * @param {CasesPostStatusEnum} [status] Status of the case.
         * @param {CasesPostCaseTypeEnum} [caseType] Type of the case.
         * @param {CasesPostPriorityEnum} [priority] Priority level of the case.
         * @param {Array<File>} [files] Attached files on upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPost: async (title: string, description: string, assignees: Array<string>, solution?: string, status?: CasesPostStatusEnum, caseType?: CasesPostCaseTypeEnum, priority?: CasesPostPriorityEnum, files?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'title' is not null or undefined
            assertParamExists('casesPost', 'title', title)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('casesPost', 'description', description)
            // verify required parameter 'assignees' is not null or undefined
            assertParamExists('casesPost', 'assignees', assignees)
            const localVarPath = `/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (solution !== undefined) { 
                localVarFormParams.append('solution', solution as any);
            }
                if (assignees) {
                localVarFormParams.append('assignees', assignees.join(COLLECTION_FORMATS.csv));
            }

    
            if (status !== undefined) { 
                localVarFormParams.append('status', status as any);
            }
    
            if (caseType !== undefined) { 
                localVarFormParams.append('case_type', caseType as any);
            }
    
            if (priority !== undefined) { 
                localVarFormParams.append('priority', priority as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific message within a given chat.
         * @summary Delete message
         * @param {number} chatId The ID of the chat containing the message.
         * @param {number} messageId The ID of the message to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsChatIdMessagesMessageIdDelete: async (chatId: number, messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('chatsChatIdMessagesMessageIdDelete', 'chatId', chatId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('chatsChatIdMessagesMessageIdDelete', 'messageId', messageId)
            const localVarPath = `/chats/{chatId}/messages/{messageId}`
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specific message within a given chat.
         * @summary Update message
         * @param {number} chatId The ID of the chat containing the message.
         * @param {number} messageId The ID of the message to update.
         * @param {string} content The new content of the message.
         * @param {string} [socketId] Optional socket ID for sending the updated message to the LLM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsChatIdMessagesMessageIdPut: async (chatId: number, messageId: number, content: string, socketId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('chatsChatIdMessagesMessageIdPut', 'chatId', chatId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('chatsChatIdMessagesMessageIdPut', 'messageId', messageId)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('chatsChatIdMessagesMessageIdPut', 'content', content)
            const localVarPath = `/chats/{chatId}/messages/{messageId}`
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (content !== undefined) { 
                localVarFormParams.append('content', content as any);
            }
    
            if (socketId !== undefined) { 
                localVarFormParams.append('socketId', socketId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all chats, ordered by creation date in descending order.
         * @summary Retrieve all chats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a chat by its ID.
         * @summary Delete a specific chat
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdDelete', 'id', id)
            const localVarPath = `/chats/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports a chat and its messages as a JSON file.
         * @summary Export a chat
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdExportGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdExportGet', 'id', id)
            const localVarPath = `/chats/{id}/export`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a chat by ID, including its messages.
         * @summary Retrieve a specific chat and its messages
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdGet', 'id', id)
            const localVarPath = `/chats/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a user message to the specified chat and sends context to the LLM.
         * @summary Add a message to a chat
         * @param {number} id 
         * @param {string} content Content of the message.
         * @param {string} socketId ID for tracking responses in real-time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesPost: async (id: number, content: string, socketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdMessagesPost', 'id', id)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('chatsIdMessagesPost', 'content', content)
            // verify required parameter 'socketId' is not null or undefined
            assertParamExists('chatsIdMessagesPost', 'socketId', socketId)
            const localVarPath = `/chats/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (content !== undefined) { 
                localVarFormParams.append('content', content as any);
            }
    
            if (socketId !== undefined) { 
                localVarFormParams.append('socketId', socketId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the title of a specified chat.
         * @summary Update chat title
         * @param {number} id 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdPut: async (id: number, title?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsIdPut', 'id', id)
            const localVarPath = `/chats/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new chat instance.
         * @summary Create a new chat
         * @param {string} [title] An optional title for the chat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPost: async (title?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a draft case with additional details and mark it as confirmed.
         * @summary Confirm and update a draft case.
         * @param {number} id ID of the case to confirm.
         * @param {string} title Title of the case.
         * @param {string} description Description of the case.
         * @param {Array<string>} assignees Person responsible for the case.
         * @param {string} [solution] Solution for the case.
         * @param {ConfirmCaseIdPutStatusEnum} [status] Status of the case.
         * @param {ConfirmCaseIdPutCaseTypeEnum} [caseType] Type of the case.
         * @param {ConfirmCaseIdPutPriorityEnum} [priority] Priority level of the case.
         * @param {Array<File>} [files] Attached files on upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCaseIdPut: async (id: number, title: string, description: string, assignees: Array<string>, solution?: string, status?: ConfirmCaseIdPutStatusEnum, caseType?: ConfirmCaseIdPutCaseTypeEnum, priority?: ConfirmCaseIdPutPriorityEnum, files?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('confirmCaseIdPut', 'id', id)
            // verify required parameter 'title' is not null or undefined
            assertParamExists('confirmCaseIdPut', 'title', title)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('confirmCaseIdPut', 'description', description)
            // verify required parameter 'assignees' is not null or undefined
            assertParamExists('confirmCaseIdPut', 'assignees', assignees)
            const localVarPath = `/confirmCase/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (solution !== undefined) { 
                localVarFormParams.append('solution', solution as any);
            }
                if (assignees) {
                localVarFormParams.append('assignees', assignees.join(COLLECTION_FORMATS.csv));
            }

    
            if (status !== undefined) { 
                localVarFormParams.append('status', status as any);
            }
    
            if (caseType !== undefined) { 
                localVarFormParams.append('case_type', caseType as any);
            }
    
            if (priority !== undefined) { 
                localVarFormParams.append('priority', priority as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload files, process them, and create draft cases.
         * @summary Create cases from uploaded files.
         * @param {Array<File>} [files] Files to be uploaded.
         * @param {string} [socketId] Socket ID for real-time communication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCaseFromFilesPost: async (files?: Array<File>, socketId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/createCaseFromFiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
            if (socketId !== undefined) { 
                localVarFormParams.append('socketId', socketId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Download an attachment by its ID.
         * @summary Download an attachment
         * @param {number} attachmentId ID of the attachment to download.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesAttachmentsAttachmentIdDownloadGet(attachmentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesAttachmentsAttachmentIdDownloadGet(attachmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesAttachmentsAttachmentIdDownloadGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an attachment by its ID.
         * @summary Retrieve an attachment
         * @param {number} attachmentId ID of the attachment to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesAttachmentsAttachmentIdGet(attachmentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesAttachmentsAttachmentIdGet(attachmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesAttachmentsAttachmentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all cases.
         * @summary Retrieve all cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an attachment associated with a case.
         * @summary Delete an attachment
         * @param {number} id ID of the case.
         * @param {number} attachmentId ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesIdAttachmentsAttachmentIdDelete(id: number, attachmentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesIdAttachmentsAttachmentIdDelete(id, attachmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesIdAttachmentsAttachmentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download an attachment associated with a case.
         * @summary Download an attachment
         * @param {number} id ID of the case.
         * @param {number} attachmentId ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesIdAttachmentsAttachmentIdDownloadGet(id: number, attachmentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesIdAttachmentsAttachmentIdDownloadGet(id, attachmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesIdAttachmentsAttachmentIdDownloadGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an attachment associated with a case.
         * @summary Retrieve an attachment
         * @param {number} id ID of the case.
         * @param {number} attachmentId ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesIdAttachmentsAttachmentIdGet(id: number, attachmentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesIdAttachmentsAttachmentIdGet(id, attachmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesIdAttachmentsAttachmentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload one or more files as attachments for a specific case.
         * @summary Upload attachments for a case
         * @param {number} id ID of the case to which the files will be attached.
         * @param {Array<File>} [files] Files to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesIdAttachmentsPost(id: number, files?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesIdAttachmentsPost(id, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesIdAttachmentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific case by its ID.
         * @summary Delete a case by ID
         * @param {number} id ID of the case to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific case by its ID.
         * @summary Retrieve a case by ID
         * @param {number} id ID of the case to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing case by its ID.
         * @summary Update a case by ID
         * @param {number} id ID of the case to update.
         * @param {string} title Title of the case.
         * @param {string} description Description of the case.
         * @param {Array<string>} assignees Person responsible for the case.
         * @param {string} [solution] Solution for the case.
         * @param {CasesIdPutStatusEnum} [status] Status of the case.
         * @param {CasesIdPutCaseTypeEnum} [caseType] Type of the case.
         * @param {CasesIdPutPriorityEnum} [priority] Priority level of the case.
         * @param {Array<File>} [files] Attached files on upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesIdPut(id: number, title: string, description: string, assignees: Array<string>, solution?: string, status?: CasesIdPutStatusEnum, caseType?: CasesIdPutCaseTypeEnum, priority?: CasesIdPutPriorityEnum, files?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesIdPut(id, title, description, assignees, solution, status, caseType, priority, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new case.
         * @summary Create a new case
         * @param {string} title Title of the case.
         * @param {string} description Description of the case.
         * @param {Array<string>} assignees Person responsible for the case.
         * @param {string} [solution] Solution for the case.
         * @param {CasesPostStatusEnum} [status] Status of the case.
         * @param {CasesPostCaseTypeEnum} [caseType] Type of the case.
         * @param {CasesPostPriorityEnum} [priority] Priority level of the case.
         * @param {Array<File>} [files] Attached files on upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPost(title: string, description: string, assignees: Array<string>, solution?: string, status?: CasesPostStatusEnum, caseType?: CasesPostCaseTypeEnum, priority?: CasesPostPriorityEnum, files?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPost(title, description, assignees, solution, status, caseType, priority, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.casesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a specific message within a given chat.
         * @summary Delete message
         * @param {number} chatId The ID of the chat containing the message.
         * @param {number} messageId The ID of the message to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsChatIdMessagesMessageIdDelete(chatId: number, messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsChatIdMessagesMessageIdDelete(chatId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsChatIdMessagesMessageIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a specific message within a given chat.
         * @summary Update message
         * @param {number} chatId The ID of the chat containing the message.
         * @param {number} messageId The ID of the message to update.
         * @param {string} content The new content of the message.
         * @param {string} [socketId] Optional socket ID for sending the updated message to the LLM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsChatIdMessagesMessageIdPut(chatId: number, messageId: number, content: string, socketId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsChatIdMessagesMessageIdPut(chatId, messageId, content, socketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsChatIdMessagesMessageIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all chats, ordered by creation date in descending order.
         * @summary Retrieve all chats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Chat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a chat by its ID.
         * @summary Delete a specific chat
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exports a chat and its messages as a JSON file.
         * @summary Export a chat
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdExportGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdExportGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdExportGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a chat by ID, including its messages.
         * @summary Retrieve a specific chat and its messages
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatWithMessages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a user message to the specified chat and sends context to the LLM.
         * @summary Add a message to a chat
         * @param {number} id 
         * @param {string} content Content of the message.
         * @param {string} socketId ID for tracking responses in real-time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdMessagesPost(id: number, content: string, socketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatsIdMessagesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdMessagesPost(id, content, socketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdMessagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the title of a specified chat.
         * @summary Update chat title
         * @param {number} id 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsIdPut(id: number, title?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdPut(id, title, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new chat instance.
         * @summary Create a new chat
         * @param {string} [title] An optional title for the chat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPost(title?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPost(title, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.chatsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a draft case with additional details and mark it as confirmed.
         * @summary Confirm and update a draft case.
         * @param {number} id ID of the case to confirm.
         * @param {string} title Title of the case.
         * @param {string} description Description of the case.
         * @param {Array<string>} assignees Person responsible for the case.
         * @param {string} [solution] Solution for the case.
         * @param {ConfirmCaseIdPutStatusEnum} [status] Status of the case.
         * @param {ConfirmCaseIdPutCaseTypeEnum} [caseType] Type of the case.
         * @param {ConfirmCaseIdPutPriorityEnum} [priority] Priority level of the case.
         * @param {Array<File>} [files] Attached files on upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmCaseIdPut(id: number, title: string, description: string, assignees: Array<string>, solution?: string, status?: ConfirmCaseIdPutStatusEnum, caseType?: ConfirmCaseIdPutCaseTypeEnum, priority?: ConfirmCaseIdPutPriorityEnum, files?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmCaseIdPut(id, title, description, assignees, solution, status, caseType, priority, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.confirmCaseIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload files, process them, and create draft cases.
         * @summary Create cases from uploaded files.
         * @param {Array<File>} [files] Files to be uploaded.
         * @param {string} [socketId] Socket ID for real-time communication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCaseFromFilesPost(files?: Array<File>, socketId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCaseFromFilesPost(files, socketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createCaseFromFilesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Download an attachment by its ID.
         * @summary Download an attachment
         * @param {DefaultApiCasesAttachmentsAttachmentIdDownloadGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesAttachmentsAttachmentIdDownloadGet(requestParameters: DefaultApiCasesAttachmentsAttachmentIdDownloadGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.casesAttachmentsAttachmentIdDownloadGet(requestParameters.attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an attachment by its ID.
         * @summary Retrieve an attachment
         * @param {DefaultApiCasesAttachmentsAttachmentIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesAttachmentsAttachmentIdGet(requestParameters: DefaultApiCasesAttachmentsAttachmentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Attachment> {
            return localVarFp.casesAttachmentsAttachmentIdGet(requestParameters.attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all cases.
         * @summary Retrieve all cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Case>> {
            return localVarFp.casesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an attachment associated with a case.
         * @summary Delete an attachment
         * @param {DefaultApiCasesIdAttachmentsAttachmentIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdAttachmentsAttachmentIdDelete(requestParameters: DefaultApiCasesIdAttachmentsAttachmentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.casesIdAttachmentsAttachmentIdDelete(requestParameters.id, requestParameters.attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Download an attachment associated with a case.
         * @summary Download an attachment
         * @param {DefaultApiCasesIdAttachmentsAttachmentIdDownloadGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdAttachmentsAttachmentIdDownloadGet(requestParameters: DefaultApiCasesIdAttachmentsAttachmentIdDownloadGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.casesIdAttachmentsAttachmentIdDownloadGet(requestParameters.id, requestParameters.attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an attachment associated with a case.
         * @summary Retrieve an attachment
         * @param {DefaultApiCasesIdAttachmentsAttachmentIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdAttachmentsAttachmentIdGet(requestParameters: DefaultApiCasesIdAttachmentsAttachmentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Attachment> {
            return localVarFp.casesIdAttachmentsAttachmentIdGet(requestParameters.id, requestParameters.attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload one or more files as attachments for a specific case.
         * @summary Upload attachments for a case
         * @param {DefaultApiCasesIdAttachmentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdAttachmentsPost(requestParameters: DefaultApiCasesIdAttachmentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Case> {
            return localVarFp.casesIdAttachmentsPost(requestParameters.id, requestParameters.files, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific case by its ID.
         * @summary Delete a case by ID
         * @param {DefaultApiCasesIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdDelete(requestParameters: DefaultApiCasesIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.casesIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific case by its ID.
         * @summary Retrieve a case by ID
         * @param {DefaultApiCasesIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdGet(requestParameters: DefaultApiCasesIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Case> {
            return localVarFp.casesIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing case by its ID.
         * @summary Update a case by ID
         * @param {DefaultApiCasesIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesIdPut(requestParameters: DefaultApiCasesIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Case> {
            return localVarFp.casesIdPut(requestParameters.id, requestParameters.title, requestParameters.description, requestParameters.assignees, requestParameters.solution, requestParameters.status, requestParameters.caseType, requestParameters.priority, requestParameters.files, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new case.
         * @summary Create a new case
         * @param {DefaultApiCasesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPost(requestParameters: DefaultApiCasesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Case> {
            return localVarFp.casesPost(requestParameters.title, requestParameters.description, requestParameters.assignees, requestParameters.solution, requestParameters.status, requestParameters.caseType, requestParameters.priority, requestParameters.files, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific message within a given chat.
         * @summary Delete message
         * @param {DefaultApiChatsChatIdMessagesMessageIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsChatIdMessagesMessageIdDelete(requestParameters: DefaultApiChatsChatIdMessagesMessageIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.chatsChatIdMessagesMessageIdDelete(requestParameters.chatId, requestParameters.messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specific message within a given chat.
         * @summary Update message
         * @param {DefaultApiChatsChatIdMessagesMessageIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsChatIdMessagesMessageIdPut(requestParameters: DefaultApiChatsChatIdMessagesMessageIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.chatsChatIdMessagesMessageIdPut(requestParameters.chatId, requestParameters.messageId, requestParameters.content, requestParameters.socketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all chats, ordered by creation date in descending order.
         * @summary Retrieve all chats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Chat>> {
            return localVarFp.chatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a chat by its ID.
         * @summary Delete a specific chat
         * @param {DefaultApiChatsIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdDelete(requestParameters: DefaultApiChatsIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.chatsIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports a chat and its messages as a JSON file.
         * @summary Export a chat
         * @param {DefaultApiChatsIdExportGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdExportGet(requestParameters: DefaultApiChatsIdExportGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.chatsIdExportGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a chat by ID, including its messages.
         * @summary Retrieve a specific chat and its messages
         * @param {DefaultApiChatsIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdGet(requestParameters: DefaultApiChatsIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatWithMessages> {
            return localVarFp.chatsIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a user message to the specified chat and sends context to the LLM.
         * @summary Add a message to a chat
         * @param {DefaultApiChatsIdMessagesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdMessagesPost(requestParameters: DefaultApiChatsIdMessagesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatsIdMessagesPost200Response> {
            return localVarFp.chatsIdMessagesPost(requestParameters.id, requestParameters.content, requestParameters.socketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the title of a specified chat.
         * @summary Update chat title
         * @param {DefaultApiChatsIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsIdPut(requestParameters: DefaultApiChatsIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.chatsIdPut(requestParameters.id, requestParameters.title, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new chat instance.
         * @summary Create a new chat
         * @param {DefaultApiChatsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPost(requestParameters: DefaultApiChatsPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Chat> {
            return localVarFp.chatsPost(requestParameters.title, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a draft case with additional details and mark it as confirmed.
         * @summary Confirm and update a draft case.
         * @param {DefaultApiConfirmCaseIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCaseIdPut(requestParameters: DefaultApiConfirmCaseIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Case> {
            return localVarFp.confirmCaseIdPut(requestParameters.id, requestParameters.title, requestParameters.description, requestParameters.assignees, requestParameters.solution, requestParameters.status, requestParameters.caseType, requestParameters.priority, requestParameters.files, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload files, process them, and create draft cases.
         * @summary Create cases from uploaded files.
         * @param {DefaultApiCreateCaseFromFilesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCaseFromFilesPost(requestParameters: DefaultApiCreateCaseFromFilesPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<Case>> {
            return localVarFp.createCaseFromFilesPost(requestParameters.files, requestParameters.socketId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for casesAttachmentsAttachmentIdDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesAttachmentsAttachmentIdDownloadGetRequest
 */
export interface DefaultApiCasesAttachmentsAttachmentIdDownloadGetRequest {
    /**
     * ID of the attachment to download.
     * @type {number}
     * @memberof DefaultApiCasesAttachmentsAttachmentIdDownloadGet
     */
    readonly attachmentId: number
}

/**
 * Request parameters for casesAttachmentsAttachmentIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesAttachmentsAttachmentIdGetRequest
 */
export interface DefaultApiCasesAttachmentsAttachmentIdGetRequest {
    /**
     * ID of the attachment to retrieve.
     * @type {number}
     * @memberof DefaultApiCasesAttachmentsAttachmentIdGet
     */
    readonly attachmentId: number
}

/**
 * Request parameters for casesIdAttachmentsAttachmentIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesIdAttachmentsAttachmentIdDeleteRequest
 */
export interface DefaultApiCasesIdAttachmentsAttachmentIdDeleteRequest {
    /**
     * ID of the case.
     * @type {number}
     * @memberof DefaultApiCasesIdAttachmentsAttachmentIdDelete
     */
    readonly id: number

    /**
     * ID of the attachment.
     * @type {number}
     * @memberof DefaultApiCasesIdAttachmentsAttachmentIdDelete
     */
    readonly attachmentId: number
}

/**
 * Request parameters for casesIdAttachmentsAttachmentIdDownloadGet operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesIdAttachmentsAttachmentIdDownloadGetRequest
 */
export interface DefaultApiCasesIdAttachmentsAttachmentIdDownloadGetRequest {
    /**
     * ID of the case.
     * @type {number}
     * @memberof DefaultApiCasesIdAttachmentsAttachmentIdDownloadGet
     */
    readonly id: number

    /**
     * ID of the attachment.
     * @type {number}
     * @memberof DefaultApiCasesIdAttachmentsAttachmentIdDownloadGet
     */
    readonly attachmentId: number
}

/**
 * Request parameters for casesIdAttachmentsAttachmentIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesIdAttachmentsAttachmentIdGetRequest
 */
export interface DefaultApiCasesIdAttachmentsAttachmentIdGetRequest {
    /**
     * ID of the case.
     * @type {number}
     * @memberof DefaultApiCasesIdAttachmentsAttachmentIdGet
     */
    readonly id: number

    /**
     * ID of the attachment.
     * @type {number}
     * @memberof DefaultApiCasesIdAttachmentsAttachmentIdGet
     */
    readonly attachmentId: number
}

/**
 * Request parameters for casesIdAttachmentsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesIdAttachmentsPostRequest
 */
export interface DefaultApiCasesIdAttachmentsPostRequest {
    /**
     * ID of the case to which the files will be attached.
     * @type {number}
     * @memberof DefaultApiCasesIdAttachmentsPost
     */
    readonly id: number

    /**
     * Files to upload.
     * @type {Array<File>}
     * @memberof DefaultApiCasesIdAttachmentsPost
     */
    readonly files?: Array<File>
}

/**
 * Request parameters for casesIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesIdDeleteRequest
 */
export interface DefaultApiCasesIdDeleteRequest {
    /**
     * ID of the case to delete.
     * @type {number}
     * @memberof DefaultApiCasesIdDelete
     */
    readonly id: number
}

/**
 * Request parameters for casesIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesIdGetRequest
 */
export interface DefaultApiCasesIdGetRequest {
    /**
     * ID of the case to retrieve.
     * @type {number}
     * @memberof DefaultApiCasesIdGet
     */
    readonly id: number
}

/**
 * Request parameters for casesIdPut operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesIdPutRequest
 */
export interface DefaultApiCasesIdPutRequest {
    /**
     * ID of the case to update.
     * @type {number}
     * @memberof DefaultApiCasesIdPut
     */
    readonly id: number

    /**
     * Title of the case.
     * @type {string}
     * @memberof DefaultApiCasesIdPut
     */
    readonly title: string

    /**
     * Description of the case.
     * @type {string}
     * @memberof DefaultApiCasesIdPut
     */
    readonly description: string

    /**
     * Person responsible for the case.
     * @type {Array<string>}
     * @memberof DefaultApiCasesIdPut
     */
    readonly assignees: Array<string>

    /**
     * Solution for the case.
     * @type {string}
     * @memberof DefaultApiCasesIdPut
     */
    readonly solution?: string

    /**
     * Status of the case.
     * @type {string}
     * @memberof DefaultApiCasesIdPut
     */
    readonly status?: CasesIdPutStatusEnum

    /**
     * Type of the case.
     * @type {string}
     * @memberof DefaultApiCasesIdPut
     */
    readonly caseType?: CasesIdPutCaseTypeEnum

    /**
     * Priority level of the case.
     * @type {string}
     * @memberof DefaultApiCasesIdPut
     */
    readonly priority?: CasesIdPutPriorityEnum

    /**
     * Attached files on upload.
     * @type {Array<File>}
     * @memberof DefaultApiCasesIdPut
     */
    readonly files?: Array<File>
}

/**
 * Request parameters for casesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiCasesPostRequest
 */
export interface DefaultApiCasesPostRequest {
    /**
     * Title of the case.
     * @type {string}
     * @memberof DefaultApiCasesPost
     */
    readonly title: string

    /**
     * Description of the case.
     * @type {string}
     * @memberof DefaultApiCasesPost
     */
    readonly description: string

    /**
     * Person responsible for the case.
     * @type {Array<string>}
     * @memberof DefaultApiCasesPost
     */
    readonly assignees: Array<string>

    /**
     * Solution for the case.
     * @type {string}
     * @memberof DefaultApiCasesPost
     */
    readonly solution?: string

    /**
     * Status of the case.
     * @type {string}
     * @memberof DefaultApiCasesPost
     */
    readonly status?: CasesPostStatusEnum

    /**
     * Type of the case.
     * @type {string}
     * @memberof DefaultApiCasesPost
     */
    readonly caseType?: CasesPostCaseTypeEnum

    /**
     * Priority level of the case.
     * @type {string}
     * @memberof DefaultApiCasesPost
     */
    readonly priority?: CasesPostPriorityEnum

    /**
     * Attached files on upload.
     * @type {Array<File>}
     * @memberof DefaultApiCasesPost
     */
    readonly files?: Array<File>
}

/**
 * Request parameters for chatsChatIdMessagesMessageIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiChatsChatIdMessagesMessageIdDeleteRequest
 */
export interface DefaultApiChatsChatIdMessagesMessageIdDeleteRequest {
    /**
     * The ID of the chat containing the message.
     * @type {number}
     * @memberof DefaultApiChatsChatIdMessagesMessageIdDelete
     */
    readonly chatId: number

    /**
     * The ID of the message to delete.
     * @type {number}
     * @memberof DefaultApiChatsChatIdMessagesMessageIdDelete
     */
    readonly messageId: number
}

/**
 * Request parameters for chatsChatIdMessagesMessageIdPut operation in DefaultApi.
 * @export
 * @interface DefaultApiChatsChatIdMessagesMessageIdPutRequest
 */
export interface DefaultApiChatsChatIdMessagesMessageIdPutRequest {
    /**
     * The ID of the chat containing the message.
     * @type {number}
     * @memberof DefaultApiChatsChatIdMessagesMessageIdPut
     */
    readonly chatId: number

    /**
     * The ID of the message to update.
     * @type {number}
     * @memberof DefaultApiChatsChatIdMessagesMessageIdPut
     */
    readonly messageId: number

    /**
     * The new content of the message.
     * @type {string}
     * @memberof DefaultApiChatsChatIdMessagesMessageIdPut
     */
    readonly content: string

    /**
     * Optional socket ID for sending the updated message to the LLM.
     * @type {string}
     * @memberof DefaultApiChatsChatIdMessagesMessageIdPut
     */
    readonly socketId?: string
}

/**
 * Request parameters for chatsIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiChatsIdDeleteRequest
 */
export interface DefaultApiChatsIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiChatsIdDelete
     */
    readonly id: number
}

/**
 * Request parameters for chatsIdExportGet operation in DefaultApi.
 * @export
 * @interface DefaultApiChatsIdExportGetRequest
 */
export interface DefaultApiChatsIdExportGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiChatsIdExportGet
     */
    readonly id: number
}

/**
 * Request parameters for chatsIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiChatsIdGetRequest
 */
export interface DefaultApiChatsIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiChatsIdGet
     */
    readonly id: number
}

/**
 * Request parameters for chatsIdMessagesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiChatsIdMessagesPostRequest
 */
export interface DefaultApiChatsIdMessagesPostRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiChatsIdMessagesPost
     */
    readonly id: number

    /**
     * Content of the message.
     * @type {string}
     * @memberof DefaultApiChatsIdMessagesPost
     */
    readonly content: string

    /**
     * ID for tracking responses in real-time.
     * @type {string}
     * @memberof DefaultApiChatsIdMessagesPost
     */
    readonly socketId: string
}

/**
 * Request parameters for chatsIdPut operation in DefaultApi.
 * @export
 * @interface DefaultApiChatsIdPutRequest
 */
export interface DefaultApiChatsIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof DefaultApiChatsIdPut
     */
    readonly id: number

    /**
     * 
     * @type {string}
     * @memberof DefaultApiChatsIdPut
     */
    readonly title?: string
}

/**
 * Request parameters for chatsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiChatsPostRequest
 */
export interface DefaultApiChatsPostRequest {
    /**
     * An optional title for the chat.
     * @type {string}
     * @memberof DefaultApiChatsPost
     */
    readonly title?: string
}

/**
 * Request parameters for confirmCaseIdPut operation in DefaultApi.
 * @export
 * @interface DefaultApiConfirmCaseIdPutRequest
 */
export interface DefaultApiConfirmCaseIdPutRequest {
    /**
     * ID of the case to confirm.
     * @type {number}
     * @memberof DefaultApiConfirmCaseIdPut
     */
    readonly id: number

    /**
     * Title of the case.
     * @type {string}
     * @memberof DefaultApiConfirmCaseIdPut
     */
    readonly title: string

    /**
     * Description of the case.
     * @type {string}
     * @memberof DefaultApiConfirmCaseIdPut
     */
    readonly description: string

    /**
     * Person responsible for the case.
     * @type {Array<string>}
     * @memberof DefaultApiConfirmCaseIdPut
     */
    readonly assignees: Array<string>

    /**
     * Solution for the case.
     * @type {string}
     * @memberof DefaultApiConfirmCaseIdPut
     */
    readonly solution?: string

    /**
     * Status of the case.
     * @type {string}
     * @memberof DefaultApiConfirmCaseIdPut
     */
    readonly status?: ConfirmCaseIdPutStatusEnum

    /**
     * Type of the case.
     * @type {string}
     * @memberof DefaultApiConfirmCaseIdPut
     */
    readonly caseType?: ConfirmCaseIdPutCaseTypeEnum

    /**
     * Priority level of the case.
     * @type {string}
     * @memberof DefaultApiConfirmCaseIdPut
     */
    readonly priority?: ConfirmCaseIdPutPriorityEnum

    /**
     * Attached files on upload.
     * @type {Array<File>}
     * @memberof DefaultApiConfirmCaseIdPut
     */
    readonly files?: Array<File>
}

/**
 * Request parameters for createCaseFromFilesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateCaseFromFilesPostRequest
 */
export interface DefaultApiCreateCaseFromFilesPostRequest {
    /**
     * Files to be uploaded.
     * @type {Array<File>}
     * @memberof DefaultApiCreateCaseFromFilesPost
     */
    readonly files?: Array<File>

    /**
     * Socket ID for real-time communication.
     * @type {string}
     * @memberof DefaultApiCreateCaseFromFilesPost
     */
    readonly socketId?: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Download an attachment by its ID.
     * @summary Download an attachment
     * @param {DefaultApiCasesAttachmentsAttachmentIdDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesAttachmentsAttachmentIdDownloadGet(requestParameters: DefaultApiCasesAttachmentsAttachmentIdDownloadGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesAttachmentsAttachmentIdDownloadGet(requestParameters.attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an attachment by its ID.
     * @summary Retrieve an attachment
     * @param {DefaultApiCasesAttachmentsAttachmentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesAttachmentsAttachmentIdGet(requestParameters: DefaultApiCasesAttachmentsAttachmentIdGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesAttachmentsAttachmentIdGet(requestParameters.attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all cases.
     * @summary Retrieve all cases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an attachment associated with a case.
     * @summary Delete an attachment
     * @param {DefaultApiCasesIdAttachmentsAttachmentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesIdAttachmentsAttachmentIdDelete(requestParameters: DefaultApiCasesIdAttachmentsAttachmentIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesIdAttachmentsAttachmentIdDelete(requestParameters.id, requestParameters.attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download an attachment associated with a case.
     * @summary Download an attachment
     * @param {DefaultApiCasesIdAttachmentsAttachmentIdDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesIdAttachmentsAttachmentIdDownloadGet(requestParameters: DefaultApiCasesIdAttachmentsAttachmentIdDownloadGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesIdAttachmentsAttachmentIdDownloadGet(requestParameters.id, requestParameters.attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an attachment associated with a case.
     * @summary Retrieve an attachment
     * @param {DefaultApiCasesIdAttachmentsAttachmentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesIdAttachmentsAttachmentIdGet(requestParameters: DefaultApiCasesIdAttachmentsAttachmentIdGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesIdAttachmentsAttachmentIdGet(requestParameters.id, requestParameters.attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload one or more files as attachments for a specific case.
     * @summary Upload attachments for a case
     * @param {DefaultApiCasesIdAttachmentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesIdAttachmentsPost(requestParameters: DefaultApiCasesIdAttachmentsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesIdAttachmentsPost(requestParameters.id, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific case by its ID.
     * @summary Delete a case by ID
     * @param {DefaultApiCasesIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesIdDelete(requestParameters: DefaultApiCasesIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific case by its ID.
     * @summary Retrieve a case by ID
     * @param {DefaultApiCasesIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesIdGet(requestParameters: DefaultApiCasesIdGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing case by its ID.
     * @summary Update a case by ID
     * @param {DefaultApiCasesIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesIdPut(requestParameters: DefaultApiCasesIdPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesIdPut(requestParameters.id, requestParameters.title, requestParameters.description, requestParameters.assignees, requestParameters.solution, requestParameters.status, requestParameters.caseType, requestParameters.priority, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new case.
     * @summary Create a new case
     * @param {DefaultApiCasesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public casesPost(requestParameters: DefaultApiCasesPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).casesPost(requestParameters.title, requestParameters.description, requestParameters.assignees, requestParameters.solution, requestParameters.status, requestParameters.caseType, requestParameters.priority, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific message within a given chat.
     * @summary Delete message
     * @param {DefaultApiChatsChatIdMessagesMessageIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public chatsChatIdMessagesMessageIdDelete(requestParameters: DefaultApiChatsChatIdMessagesMessageIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsChatIdMessagesMessageIdDelete(requestParameters.chatId, requestParameters.messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a specific message within a given chat.
     * @summary Update message
     * @param {DefaultApiChatsChatIdMessagesMessageIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public chatsChatIdMessagesMessageIdPut(requestParameters: DefaultApiChatsChatIdMessagesMessageIdPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsChatIdMessagesMessageIdPut(requestParameters.chatId, requestParameters.messageId, requestParameters.content, requestParameters.socketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all chats, ordered by creation date in descending order.
     * @summary Retrieve all chats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public chatsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a chat by its ID.
     * @summary Delete a specific chat
     * @param {DefaultApiChatsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public chatsIdDelete(requestParameters: DefaultApiChatsIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports a chat and its messages as a JSON file.
     * @summary Export a chat
     * @param {DefaultApiChatsIdExportGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public chatsIdExportGet(requestParameters: DefaultApiChatsIdExportGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdExportGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a chat by ID, including its messages.
     * @summary Retrieve a specific chat and its messages
     * @param {DefaultApiChatsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public chatsIdGet(requestParameters: DefaultApiChatsIdGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a user message to the specified chat and sends context to the LLM.
     * @summary Add a message to a chat
     * @param {DefaultApiChatsIdMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public chatsIdMessagesPost(requestParameters: DefaultApiChatsIdMessagesPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdMessagesPost(requestParameters.id, requestParameters.content, requestParameters.socketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the title of a specified chat.
     * @summary Update chat title
     * @param {DefaultApiChatsIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public chatsIdPut(requestParameters: DefaultApiChatsIdPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsIdPut(requestParameters.id, requestParameters.title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new chat instance.
     * @summary Create a new chat
     * @param {DefaultApiChatsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public chatsPost(requestParameters: DefaultApiChatsPostRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).chatsPost(requestParameters.title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a draft case with additional details and mark it as confirmed.
     * @summary Confirm and update a draft case.
     * @param {DefaultApiConfirmCaseIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public confirmCaseIdPut(requestParameters: DefaultApiConfirmCaseIdPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).confirmCaseIdPut(requestParameters.id, requestParameters.title, requestParameters.description, requestParameters.assignees, requestParameters.solution, requestParameters.status, requestParameters.caseType, requestParameters.priority, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload files, process them, and create draft cases.
     * @summary Create cases from uploaded files.
     * @param {DefaultApiCreateCaseFromFilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createCaseFromFilesPost(requestParameters: DefaultApiCreateCaseFromFilesPostRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createCaseFromFilesPost(requestParameters.files, requestParameters.socketId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CasesIdPutStatusEnum = {
    Open: 'Open',
    InProgress: 'In Progress',
    Solved: 'Solved',
    Closed: 'Closed'
} as const;
export type CasesIdPutStatusEnum = typeof CasesIdPutStatusEnum[keyof typeof CasesIdPutStatusEnum];
/**
 * @export
 */
export const CasesIdPutCaseTypeEnum = {
    Problem: 'Problem',
    Incident: 'Incident',
    Change: 'Change',
    Faq: 'FAQ'
} as const;
export type CasesIdPutCaseTypeEnum = typeof CasesIdPutCaseTypeEnum[keyof typeof CasesIdPutCaseTypeEnum];
/**
 * @export
 */
export const CasesIdPutPriorityEnum = {
    Low: 'Low',
    Medium: 'Medium',
    High: 'High'
} as const;
export type CasesIdPutPriorityEnum = typeof CasesIdPutPriorityEnum[keyof typeof CasesIdPutPriorityEnum];
/**
 * @export
 */
export const CasesPostStatusEnum = {
    Open: 'Open',
    InProgress: 'In Progress',
    Solved: 'Solved',
    Closed: 'Closed'
} as const;
export type CasesPostStatusEnum = typeof CasesPostStatusEnum[keyof typeof CasesPostStatusEnum];
/**
 * @export
 */
export const CasesPostCaseTypeEnum = {
    Problem: 'Problem',
    Incident: 'Incident',
    Change: 'Change',
    Faq: 'FAQ'
} as const;
export type CasesPostCaseTypeEnum = typeof CasesPostCaseTypeEnum[keyof typeof CasesPostCaseTypeEnum];
/**
 * @export
 */
export const CasesPostPriorityEnum = {
    Low: 'Low',
    Medium: 'Medium',
    High: 'High'
} as const;
export type CasesPostPriorityEnum = typeof CasesPostPriorityEnum[keyof typeof CasesPostPriorityEnum];
/**
 * @export
 */
export const ConfirmCaseIdPutStatusEnum = {
    Open: 'Open',
    InProgress: 'In Progress',
    Solved: 'Solved',
    Closed: 'Closed'
} as const;
export type ConfirmCaseIdPutStatusEnum = typeof ConfirmCaseIdPutStatusEnum[keyof typeof ConfirmCaseIdPutStatusEnum];
/**
 * @export
 */
export const ConfirmCaseIdPutCaseTypeEnum = {
    Problem: 'Problem',
    Incident: 'Incident',
    Change: 'Change',
    Faq: 'FAQ'
} as const;
export type ConfirmCaseIdPutCaseTypeEnum = typeof ConfirmCaseIdPutCaseTypeEnum[keyof typeof ConfirmCaseIdPutCaseTypeEnum];
/**
 * @export
 */
export const ConfirmCaseIdPutPriorityEnum = {
    Low: 'Low',
    Medium: 'Medium',
    High: 'High'
} as const;
export type ConfirmCaseIdPutPriorityEnum = typeof ConfirmCaseIdPutPriorityEnum[keyof typeof ConfirmCaseIdPutPriorityEnum];


